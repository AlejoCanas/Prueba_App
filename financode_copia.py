# -*- coding: utf-8 -*-
"""Financode_Copia.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Kbl8dVkl6STALcfjNtqh733_bRoxJYHs
"""

# Proyecto: Financode
# Desarrollado por: Alejandro Ca√±as, Emmanuel Garc√≠a, Maricielo G√≥mez
# Descripci√≥n: App que determina el perfil del inversor y analiza acciones con Python.

# pip install streamlit yfinance

# pip install streamlit-option-menu

# Importar librerias ----
import streamlit as st #Interfaz intercativo
import pandas as pd #Manejo de dataframes
import numpy as np #Soporte de c√°lculo matem√°ticos y matrices
import yfinance as yf #Datos financieros de Yahoo Finance
import matplotlib.pyplot as plt #Gr√°ficos y visualizaciones de datos
import datetime #Manejo de fechas
from streamlit_option_menu import option_menu

# Inicializar variable de sesi√≥n ---
if "perfil" not in st.session_state:
    st.session_state.perfil = None

# Crear men√∫ lateral
with st.sidebar:
    seleccion = option_menu(
        "FinanCode",
        ["Inicio", "Perfil de inversor", "Simulaci√≥n de portafolio: Una acci√≥n", "Simulaci√≥n de portafolio: Dos o m√°s acciones", "Referencias"],
        icons=["house", "graph-up", "bar-chart", "gear"],
        menu_icon="cast",
        default_index=0,
        orientation="vertical",
    )

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import datetime
import plotly.graph_objects as go 
# Usaremos Plotly para mejores gr√°ficos

# --- CONFIGURACI√ìN DE P√ÅGINA ---
# (Aseg√∫rate de que esta sea la primera comando de Streamlit)
st.set_page_config(
    page_title="FinanCode",
    page_icon="üí∞",
    layout="wide",
    initial_sidebar_state="expanded",
)

# --- IMPORTANTE: INICIALIZACI√ìN DE st.session_state ---
# Esto es crucial para que la app funcione entre pesta√±as
if 'perfil' not in st.session_state:
    st.session_state.perfil = None

# --- BARRA LATERAL (SIDEBAR) ---
with st.sidebar:
    st.title("FinanCode 1.0")
    seleccion = st.radio(
        "Men√∫ de navegaci√≥n",
        ["Inicio", "Perfil de inversor", "An√°lisis de Portafolio", "Configuraci√≥n"],
        captions=[
            "Bienvenida",
            "Define tu tolerancia al riesgo",
            "Simula tu portafolio",
            "Ajustes de la app"
        ]
    )
    st.markdown("---")
    st.markdown("*Desarrollado por: Alejandro Ca√±as, Emmanuel Garc√≠a, Maricielo G√≥mez*")


# --- CONTENIDO DIN√ÅMICO ---
if seleccion == "Inicio":
    st.title("üí∞ Bienvenido a FinanCode")
    st.header("‚ú® Tu estilo, tu riesgo, tu inversi√≥n.")
    st.markdown("""
    Esta app te ayuda a identificar tu *perfil de inversor* y analizar el comportamiento de un portafolio de acciones reales,
    cumpliendo con los requisitos clave del an√°lisis financiero.
    """)

    st.subheader("Requisitos Cumplidos (seg√∫n especificaciones):")

    col_req1, col_req2 = st.columns(2)

    with col_req1:
        st.markdown("""
        #### 1. Entradas de Usuario
        *   **‚úÖ Selecci√≥n de empresas:** Ingresa m√∫ltiples tickers (ej: AAPL, MSFT).
        *   **‚úÖ Pesos del portafolio:** Asigna un peso porcentual a cada activo.
        *   **‚úÖ Inversi√≥n inicial:** Define el monto monetario para la simulaci√≥n.
        *   **‚úÖ Periodo de an√°lisis:** Selecciona fecha de inicio y fin.
        *   **‚úÖ Tasa Libre de Riesgo:** Ajusta el 'Risk-Free Rate' para el Sharpe Ratio.

        #### 2. Visualizaciones
        *   **‚úÖ Serie de tiempo de precios:** Gr√°fico de precios normalizados.
        *   **‚úÖ Retornos acumulados:** Gr√°fico de retornos acumulados del portafolio.
        *   **‚úÖ Evoluci√≥n del valor monetario:** Gr√°fico del valor de tu inversi√≥n.
        *   **‚úÖ Diagrama riesgo-retorno:** Compara activos vs. portafolio.
        *   **‚úÖ Benchmark (Opcional):** M√©tricas Beta vs. S&P 500.
        """)

    with col_req2:
        st.markdown("""
        #### 3. Resultados M√≠nimos
        *   **‚úÖ Retornos por periodo y acumulados:** Calculados para el portafolio.
        *   **‚úÖ Volatilidad hist√≥rica y anualizada:** Calculada para el portafolio.
        *   **‚úÖ Sharpe ratio:** Calculado para el portafolio.
        *   **‚úÖ Evoluci√≥n del valor monetario:** Mostrado en m√©trica y gr√°fico.

        #### 4. Fuente de Datos y Lenguaje
        *   **‚úÖ Lenguaje:** Python (Streamlit).
        *   **‚úÖ Fuente de datos:** API de Yahoo Finance (`yfinance`).
        """)

elif seleccion == "Perfil de inversor":

    # üß≠ CUESTIONARIO DE PERFIL
    st.title("üß© Cuestionario del inversor")
    st.header("üë§ Descubre tu perfil de inversor")
    st.markdown("Responde las siguientes preguntas para determinar tu tolerancia al riesgo, horizonte y conocimiento.")
    st.markdown("---")

    puntaje_total = 0

    # --- SECCI√ìN I: TOLERANCIA AL RIESGO ---
    st.subheader("I. Tolerancia al riesgo (Tu reacci√≥n a la volatilidad)")

    q1 = st.radio(
        "1. Si tus acciones cayeran un 20% en un mes, t√∫...",
        [
            "Vender√≠as todo para evitar m√°s p√©rdidas.",
            "Mantendr√≠as la posici√≥n esperando la recuperaci√≥n.",
            "Aumentar√≠as tu inversi√≥n aprovechando los precios bajos."
        ],
        index=None
    )
    if q1:
        puntaje_total += [1, 3, 5][["Vender√≠as" in q1, "Mantendr√≠as" in q1, "Aumentar√≠as" in q1].index(True)]

    q2 = st.radio(
        "2. ¬øQu√© priorizas al invertir?",
        [
            "Seguridad y estabilidad del capital.",
            "Equilibrio entre crecimiento y seguridad.",
            "Rendimiento alto, aceptando fluctuaciones fuertes."
        ],
        index=None
    )
    if q2:
        puntaje_total += [1, 3, 5][["Seguridad" in q2, "Equilibrio" in q2, "Rendimiento" in q2].index(True)]

    q3 = st.radio(
        "3. ¬øQu√© nivel de ca√≠da podr√≠as tolerar en un a√±o?",
        [
            "Hasta 5%. Prefiero estabilidad.",
            "Entre 10% y 20%. Entiendo que los mercados bajan.",
            "M√°s del 25%. Asumo riesgos para buscar mayores retornos."
        ],
        index=None
    )
    if q3:
        puntaje_total += [1, 3, 5][["5%" in q3, "10%" in q3, "25%" in q3].index(True)]

    st.markdown("---")

    # --- SECCI√ìN II: HORIZONTE DE INVERSI√ìN ---
    st.subheader("II. Horizonte de inversi√≥n (Plazo)")

    q4 = st.radio(
        "4. ¬øCon qu√© objetivo inviertes principalmente?",
        [
            "Necesidades o gastos en el corto plazo (1 a 3 a√±os).",
            "Ahorros para metas en el mediano plazo (3 a 7 a√±os).",
            "Construir patrimonio o jubilaci√≥n (m√°s de 7 a√±os)."
        ],
        index=None
    )
    if q4:
        puntaje_total += [1, 3, 5][["corto" in q4, "mediano" in q4, "largo" in q4 or "m√°s" in q4].index(True)]

    q5 = st.radio(
        "5. ¬øCu√°ndo esperas usar la mayor√≠a de tu capital invertido?",
        [
            "Antes de 2 a√±os.",
            "En 5 a 10 a√±os.",
            "En m√°s de 15 a√±os."
        ],
        index=None
    )
    if q5:
        puntaje_total += [1, 3, 5][["Antes" in q5, "5 a 10" in q5, "15" in q5].index(True)]

    st.markdown("---")

    # --- SECCI√ìN III: CONOCIMIENTO Y EXPERIENCIA ---
    st.subheader("III. Conocimiento y experiencia")

    q6 = st.radio(
        "6. ¬øQu√© tan familiarizado est√°s con indicadores como el Ratio de Sharpe o el modelo CAPM?",
        [
            "No los conozco.",
            "He escuchado de ellos y entiendo lo b√°sico.",
            "Los uso en mis an√°lisis o estudios financieros."
        ],
        index=None
    )
    if q6:
        puntaje_total += [1, 3, 5][["No los conozco" in q6, "b√°sico" in q6, "uso" in q6].index(True)]

    q7 = st.radio(
        "7. ¬øEn qu√© tipo de activos sueles invertir o analizar?",
        [
            "Solo cuentas de ahorro o fondos conservadores.",
            "Acciones y bonos. Conozco los riesgos del mercado.",
            "Acciones, derivados o criptomonedas. Manejo portafolios activos."
        ],
        index=None
    )
    if q7:
        puntaje_total += [1, 3, 5][["ahorro" in q7, "Acciones y bonos" in q7, "criptomonedas" in q7].index(True)]

    st.markdown("---")

    # --- RESULTADO ---
    preguntas_respondidas = all([q1, q2, q3, q4, q5, q6, q7])

    if st.button("Calcular mi perfil de inversi√≥n"):
        if preguntas_respondidas:
            st.subheader("üéØ Resultado de tu perfil de inversi√≥n en acciones")
            st.metric("Puntuaci√≥n Total", puntaje_total)

            if puntaje_total <= 15:
                perfil = "Conservador üõ°Ô∏è"
                st.success(f"Tu perfil es: **{perfil}**")
                st.write("Prefieres estabilidad. Te convienen acciones de empresas grandes y consolidadas.")
                st.session_state.perfil = "CONSERVADOR"

            elif puntaje_total <= 25:
                perfil = "Moderado üåø"
                st.info(f"Tu perfil es: **{perfil}**")
                st.write("Buscas equilibrio. Puedes combinar acciones consolidadas con sectores de crecimiento moderado.")
                st.session_state.perfil = "MODERADO"

            else:
                perfil = "Agresivo üî•"
                st.warning(f"Tu perfil es: **{perfil}**")
                st.write("Tienes alta tolerancia al riesgo. Podr√≠as enfocarte en acciones de alto crecimiento, emergentes o tecnolog√≠a, usando an√°lisis de Sharpe o CAPM.")
                st.session_state.perfil = "AGRESIVO"

        else:
            st.error("Por favor responde todas las preguntas antes de calcular tu perfil.")

elif seleccion == "An√°lisis de Portafolio":
    st.header("üìà An√°lisis y Simulaci√≥n de Portafolio")

    if st.session_state.perfil is None:
        st.error("üõë Por favor, completa el **Cuestionario del Inversor** en la pesta√±a anterior para desbloquear la simulaci√≥n.")
    else:
        st.success(f"Perfil Actual: **{st.session_state.perfil}**. ¬°Configura tu simulaci√≥n!")
        st.markdown("---")

        # --- REQ 3: ENTRADAS M√çNIMAS ---

        # 1. Selecci√≥n de empresas
        st.subheader("1. Selecci√≥n de Activos")
        tickers_input = st.text_input(
            "Ingrese los Tickers separados por comas (ej: AAPL, MSFT, GOOG, MELI)",
            value="AAPL,MSFT,GOOG"
        )
        tickers = [t.strip().upper() for t in tickers_input.split(",") if t.strip()]

        # 2. Pesos del portafolio
        st.subheader("2. Asignaci√≥n de Pesos (%)")
        pesos_pct = []
        if not tickers:
            st.warning("Por favor, ingrese al menos un ticker.")
        else:
            weight_cols = st.columns(len(tickers))
            default_weight = 100.0 / len(tickers)
            for i, ticker in enumerate(tickers):
                with weight_cols[i]:
                    peso_individual = st.number_input(
                        f"Peso % para {ticker}",
                        min_value=0.0,
                        max_value=100.0,
                        value=default_weight,
                        step=1.0,
                        format="%.2f"
                    )
                    pesos_pct.append(peso_individual)

            total_weight = sum(pesos_pct)
            if not np.isclose(total_weight, 100.0):
                st.error(f"El total de los pesos es {total_weight:.2f}%. Debe sumar 100%.")
            else:
                st.success(f"Pesos asignados correctamente. Total: {total_weight:.0f}%.")

        st.markdown("---")

        # 3. Inversi√≥n inicial, Periodo y Frecuencia (impl√≠cita)
        st.subheader("3. Configuraci√≥n de Simulaci√≥n")

        sim_col1, sim_col2 = st.columns(2)

        with sim_col1:
            # 3.a. Inversi√≥n inicial
            inversion_inicial = st.number_input(
                "Inversi√≥n Inicial ($)",
                min_value=1.0,
                value=10000.0,
                step=1000.0,
                help="Monto monetario inicial para la simulaci√≥n."
            )

            # 3.b. Tasa Libre de Riesgo (para Sharpe)
            RF = st.number_input(
                "Tasa Libre de Riesgo (Anual)",
                min_value=0.0,
                max_value=1.0,
                value=0.04, # 4% por defecto
                step=0.005,
                format="%.3f",
                help="Tasa de referencia (ej: Bonos del Tesoro) para calcular el Ratio de Sharpe."
            )

        with sim_col2:
            # 3.c. Periodo de an√°lisis
            today = datetime.date.today()
            three_years_ago = today - datetime.timedelta(days=3 * 365)

            d = st.date_input(
                "Seleccione el per√≠odo hist√≥rico para el an√°lisis",
                value=(three_years_ago, today),
                min_value=datetime.date(1990, 1, 1),
                max_value=today,
                format="YYYY-MM-DD",
            )

        start_date = d[0]
        end_date = d[1]

        # Benchmark Ticker (S&P 500)
        MARKET_TICKER = "^GSPC"

        st.markdown("---")

        # --- BOT√ìN DE EJECUCI√ìN ---
        if st.button("Ejecutar An√°lisis de Portafolio", type="primary"):

            # Validaciones de entrada
            if not tickers:
                st.error("Error: No se han ingresado tickers.")
            elif not np.isclose(sum(pesos_pct), 100.0):
                st.error("Error: Los pesos no suman 100%.")
            else:
                with st.spinner("Descargando datos y calculando m√©tricas..."):

                    # Normalizar pesos a decimal
                    pesos = np.array(pesos_pct) / 100.0

                    # --- Definici√≥n de Funciones ---

                    def get_data(tickers, start_date, end_date, benchmark_ticker="^GSPC"):
                        """Descarga datos de precios de cierre ajustados."""
                        all_tickers = tickers + [benchmark_ticker]
                        data = yf.download(all_tickers, start=start_date, end=end_date)['Close']

                        # Manejar el caso de un solo ticker (devuelve Series)
                        if isinstance(data, pd.Series):
                            data = data.to_frame(name=all_tickers[0])

                        # Separar activos y benchmark
                        asset_data = data[tickers]
                        benchmark_data = data[benchmark_ticker].to_frame(name=benchmark_ticker)

                        # Manejar caso de un solo ticker en el portafolio
                        if len(tickers) == 1:
                            asset_data = asset_data.to_frame(name=tickers[0])

                        return asset_data.dropna(), benchmark_data.dropna()

                    def calculate_beta(asset_returns, benchmark_returns):
                        """Calcula beta para cada activo contra el benchmark."""
                        betas = {}
                        # Asegurar que benchmark_returns sea una Serie
                        bench_series = benchmark_returns.iloc[:, 0]

                        # Alineamos los √≠ndices por si acaso
                        aligned_assets, aligned_bench = asset_returns.align(bench_series, join='inner', axis=0)

                        if aligned_assets.empty:
                            return {col: np.nan for col in asset_returns.columns}

                        benchmark_variance = aligned_bench.var()

                        if benchmark_variance == 0:
                            return {col: np.nan for col in asset_returns.columns}

                        for column in aligned_assets.columns:
                            covariance = aligned_assets[column].cov(aligned_bench)
                            beta = covariance / benchmark_variance
                            betas[column] = beta
                        return betas

                    # --- Ejecuci√≥n de C√°lculos ---
                    try:
                        datos, benchmark_data = get_data(tickers, start_date, end_date, MARKET_TICKER)

                        if datos.empty:
                            st.error("No se pudieron descargar los datos. Revise los tickers o el rango de fechas.")

                        # --- C√ÅLCULOS INDIVIDUALES ---
                        retornos = datos.pct_change().dropna()
                        benchmark_retornos = benchmark_data.pct_change().dropna()

                        # Asegurar alineaci√≥n de retornos
                        retornos_aligned, benchmark_retornos_aligned = retornos.align(benchmark_retornos.iloc[:, 0], join='inner', axis=0)

                        if retornos_aligned.empty:
                             st.error("No hay datos comunes entre los activos y el benchmark en el per√≠odo seleccionado.")
                             st.stop()

                        benchmark_retornos_df = benchmark_retornos_aligned.to_frame(name=MARKET_TICKER)

                        retorno_anual_ind = retornos_aligned.mean() * 252
                        volatilidad_anual_ind = retornos_aligned.std() * np.sqrt(252)
                        sharpe_anual_ind = (retorno_anual_ind - RF) / volatilidad_anual_ind
                        matriz_cov = retornos_aligned.cov() * 252

                        # CAPM y Beta
                        betas = calculate_beta(retornos_aligned, benchmark_retornos_df)
                        Rm = benchmark_retornos_aligned.mean() * 252
                        retorno_capm_series = pd.Series({t: RF + beta * (Rm - RF) for t, beta in betas.items()})

                        # --- REQ 4: C√ÅLCULOS DE PORTAFOLIO ---
                        retorno_p = np.dot(pesos, retorno_anual_ind)
                        volatilidad_p = np.sqrt(np.dot(pesos.T, np.dot(matriz_cov, pesos)))
                        sharpe_p = (retorno_p - RF) / volatilidad_p

                        # Retornos diarios del portafolio
                        retornos_diarios_p = (retornos_aligned * pesos).sum(axis=1)

                        # Retornos acumulados del portafolio
                        retornos_acum_p = (1 + retornos_diarios_p).cumprod()

                        # Evoluci√≥n monetaria
                        valor_portafolio = inversion_inicial * retornos_acum_p


                        # --- PRESENTACI√ìN DE RESULTADOS ---

                        st.subheader("Resultados del Portafolio")
                        st.markdown(f"**Per√≠odo:** {start_date.strftime('%Y-%m-%d')} a {end_date.strftime('%Y-%m-%d')}")

                        # --- REQ 4: RESULTADOS M√çNIMOS (M√âTRICAS) ---
                        res_col1, res_col2, res_col3, res_col4 = st.columns(4)
                        with res_col1:
                            st.metric("Valor Final ($)", f"${valor_portafolio.iloc[-1]:,.2f}")
                        with res_col2:
                            st.metric("Retorno Anualizado", f"{retorno_p*100:.2f}%")
                        with res_col3:
                            st.metric("Volatilidad Anualizada", f"{volatilidad_p*100:.2f}%")
                        with res_col4:
                            st.metric("Ratio de Sharpe", f"{sharpe_p:.2f}")

                        # --- REQ 5: VISUALIZACIONES M√çNIMAS ---

                        tab1, tab2, tab3 = st.tabs([
                            "üìà Evoluci√≥n y Riesgo-Retorno",
                            "üìä M√©tricas Individuales (Benchmark)",
                            "üìâ Precios Hist√≥ricos"
                        ])

                        with tab1:
                            st.subheader("Evoluci√≥n del Valor Monetario del Portafolio")
                            st.line_chart(valor_portafolio)

                            st.subheader("Retornos Acumulados del Portafolio")
                            st.line_chart(retornos_acum_p)

                            st.subheader("Diagrama Riesgo-Retorno")
                            # Crear DataFrame para el gr√°fico
                            df_riesgo_retorno = pd.DataFrame({
                                'Retorno': retorno_anual_ind,
                                'Volatilidad': volatilidad_anual_ind,
                                'Tipo': 'Activo Individual'
                            })
                            # A√±adir datos del portafolio
                            df_riesgo_retorno.loc['Portafolio'] = {
                                'Retorno': retorno_p,
                                'Volatilidad': volatilidad_p,
                                'Tipo': 'Mi Portafolio'
                            }
                            df_riesgo_retorno = df_riesgo_retorno.reset_index().rename(columns={'index': 'Activo'})

                            # Gr√°fico de dispersi√≥n
                            st.scatter_chart(
                                df_riesgo_retorno,
                                x='Volatilidad',
                                y='Retorno',
                                color='Tipo',
                                size=60,
                                tooltip=['Activo', 'Volatilidad', 'Retorno']
                            )
                            st.caption("Nota: 'Mi Portafolio' muestra el riesgo y retorno combinados seg√∫n los pesos asignados.")

                        with tab2:
                            st.subheader("M√©tricas Individuales de Activos (vs. Benchmark)")
                            metricas_df = pd.DataFrame({
                                'Peso Asignado': pd.Series(pesos, index=tickers).apply(lambda x: f"{x*100:.1f}%"),
                                'Retorno Anual (Hist√≥rico)': retorno_anual_ind.apply(lambda x: f"{x*100:.2f}%"),
                                'Retorno Esperado (CAPM)': retorno_capm_series.apply(lambda x: f"{x*100:.2f}%"),
                                'Volatilidad Anual (Riesgo)': volatilidad_anual_ind.apply(lambda x: f"{x*100:.2f}%"),
                                f'Beta (vs. {MARKET_TICKER})': pd.Series(betas).round(2),
                                'Ratio de Sharpe': sharpe_anual_ind.round(2)
                            })
                            st.dataframe(metricas_df, use_container_width=True)

                        with tab3:
                            st.subheader("Evoluci√≥n Hist√≥rica de Precios (Normalizados)")
                            st.markdown("Precios ajustados, normalizados a 1 al inicio del per√≠odo para comparar el crecimiento.")
                            datos_normalizados = datos / datos.iloc[0]
                            st.line_chart(datos_normalizados)


                    except Exception as e:
                        st.error(f"Ocurri√≥ un error durante la simulaci√≥n: {e}")
                        st.exception(e)


elif seleccion == "Configuraci√≥n":
    st.header("‚öôÔ∏è Configuraci√≥n de usuario")
    st.write("Esta secci√≥n est√° reservada para futuras configuraciones, como guardar perfiles o cambiar temas.")
